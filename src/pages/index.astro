---
import { getCollection } from "astro:content";
import Layout from "../layouts/Layout.astro";
import {
  calculateMonthlyData,
  analyzeExpensesByCategory,
  categorizeIncome,
  categorizeMonthlyIncome,
  analyzeSalariedExpenses,
  calculateRunwayProjection,
  calculateSalaryPercentageOfIncome,
  getTopContributors,
  getTopExpenses,
  getLargestOneTimeContributions,
  analyzeOtherIncome,
} from "../lib/analysis";

const transactionsCollection = await getCollection("transactions");
const transactions = transactionsCollection.map((t) => t.data);

const monthlyData = calculateMonthlyData(transactions);
const expensesByCategory = analyzeExpensesByCategory(transactions);
const incomeSources = categorizeIncome(transactions);
const monthlyIncomeSources = categorizeMonthlyIncome(transactions);
const salariedExpenses = analyzeSalariedExpenses(transactions);
const runway = calculateRunwayProjection(transactions);
const salaryAnalysis = calculateSalaryPercentageOfIncome(transactions);
const topContributors = getTopContributors(transactions, 15);
const topExpenses = getTopExpenses(transactions, 15);
const largestOneTime = getLargestOneTimeContributions(transactions, 5);
const otherIncomeBreakdown = analyzeOtherIncome(transactions);

const formatCurrency = (amount: number) =>
  new Intl.NumberFormat("en-US", { style: "currency", currency: "USD" }).format(amount);

const totalIncome = monthlyData.reduce((sum, m) => sum + m.income, 0);
const totalExpenses = monthlyData.reduce((sum, m) => sum + m.expenses, 0);
---

<Layout title="Astro OpenCollective Budget Analysis">
  <section class="hero-section">
    <div class="hero-left">
      <div class="summary-cards">
        <div class="card highlight current-balance">
          <h3>Current Balance</h3>
          <p class="value" class:list={{ positive: runway.currentBalance > 0, negative: runway.currentBalance < 0 }}>
            {formatCurrency(runway.currentBalance)}
          </p>
        </div>
        <div class="card">
          <h3>Avg Monthly Income</h3>
          <p class="value positive">{formatCurrency(runway.averageMonthlyIncome)}</p>
        </div>
        <div class="card">
          <h3>Avg Monthly Expenses</h3>
          <p class="value negative">{formatCurrency(runway.averageMonthlyExpenses)}</p>
        </div>
        <div class="card">
          <h3>Avg Monthly Diff</h3>
          <p class="value" class:list={{ positive: runway.averageMonthlyNet > 0, negative: runway.averageMonthlyNet < 0 }}>
            {formatCurrency(runway.averageMonthlyNet)}
          </p>
        </div>
        <div class="card">
          <h3>All-Time Income</h3>
          <p class="value positive">{formatCurrency(totalIncome)}</p>
        </div>
        <div class="card">
          <h3>All-Time Expenses</h3>
          <p class="value negative">{formatCurrency(totalExpenses)}</p>
        </div>
        <div class="card highlight">
          <h3>Runway</h3>
          <p class="value" class:list={{ warning: runway.monthsOfRunway < 12 && runway.monthsOfRunway !== Infinity }}>
            {runway.monthsOfRunway === Infinity ? "Sustainable" : `${runway.monthsOfRunway} months`}
          </p>
        </div>
      </div>
      <p class="hero-note">
        {transactions.length.toLocaleString()} transactions from {monthlyData[0]?.month} to {monthlyData[monthlyData.length - 1]?.month}.
        Figures differ from Open Collective dashboard, which excludes host fees (~10%) from totals.
      </p>
    </div>
    <div class="chart-section expense-chart">
      <h2>Expense Categories</h2>
      <p class="note category-note">
        <span><strong>Paid Maintainers:</strong> Consultant fees and core maintainer stipends.</span>
        <span><strong>Community Incentives:</strong> Grants, awards, and community support.</span>
        <span><strong>Miscellaneous:</strong> Travel, donations, and uncategorized expenses.</span>
        <span><strong>OC Fees:</strong> Open Collective fees (~10%).</span>
      </p>
      <div class="chart-container small">
        <canvas id="expenseCategoryChart"></canvas>
      </div>
    </div>
  </section>

  <section class="chart-section">
    <h2>Monthly Income vs Expenses</h2>
    <div class="chart-container">
      <canvas id="monthlyChart"></canvas>
    </div>
  </section>

  <section class="chart-section">
    <h2>Cumulative Balance Over Time</h2>
    <div class="chart-container">
      <canvas id="balanceChart"></canvas>
    </div>
  </section>

  <section class="chart-section">
    <h2>Income Sources</h2>
    <div class="stats-row">
      <div class="stat">
        <span class="stat-label">GitHub Sponsors</span>
        <span class="stat-value">{formatCurrency(incomeSources.githubSponsors.amount)}</span>
        <span class="stat-count">({incomeSources.githubSponsors.count} transfers)</span>
      </div>
      <div class="stat">
        <span class="stat-label">OC Recurring</span>
        <span class="stat-value positive">{formatCurrency(incomeSources.ocRecurring.amount)}</span>
        <span class="stat-count">({incomeSources.ocRecurring.count} contributions)</span>
      </div>
      <div class="stat">
        <span class="stat-label">OC One-Time</span>
        <span class="stat-value">{formatCurrency(incomeSources.ocOneTime.amount)}</span>
        <span class="stat-count">({incomeSources.ocOneTime.count} contributions)</span>
      </div>
      {incomeSources.other.amount > 0 && (
        <div class="stat">
          <span class="stat-label">Other</span>
          <span class="stat-value">{formatCurrency(incomeSources.other.amount)}</span>
          <span class="stat-count">({incomeSources.other.count} transactions)</span>
        </div>
      )}
    </div>
    <p class="note category-note">
      <span><strong>GitHub Sponsors:</strong> Periodic lump-sum transfers from GitHub.</span>
      <span><strong>OC Recurring:</strong> Monthly contributions via OpenCollective.</span>
      <span><strong>OC One-Time:</strong> Single contributions via OpenCollective.</span>
      <span><strong>Other:</strong> Host fees, payment processor covers, refunds.</span>
      <span>Values that exceed the scale are clamped and marked with a triangleâ€”hover for actual amount.</span>
    </p>
    <div class="chart-container small">
      <canvas id="incomeSourcesChart"></canvas>
    </div>
  </section>

  {otherIncomeBreakdown.length > 0 && (
    <section class="chart-section">
      <h2>Other Income Breakdown</h2>
      <p class="note">
        Breakdown of the {formatCurrency(incomeSources.other.amount)} in "Other" income ({incomeSources.other.count} transactions).
        These are credits that aren't GitHub Sponsors or OpenCollective contributions.
      </p>
      <div class="other-income-layout">
        <div class="chart-container small">
          <canvas id="otherIncomeChart"></canvas>
        </div>
        <div class="table-container">
          <table class="expandable-table" data-visible="5">
            <thead>
              <tr>
                <th>Type</th>
                <th>Source</th>
                <th class="number">Amount</th>
                <th class="number">Count</th>
              </tr>
            </thead>
            <tbody>
              {otherIncomeBreakdown.map((item, i) => (
                <tr class:list={{ hidden: i >= 5 }}>
                  <td>{item.kind}</td>
                  <td>{item.source || "Unknown"}</td>
                  <td class="number positive">{formatCurrency(item.amount)}</td>
                  <td class="number">{item.count}</td>
                </tr>
              ))}
            </tbody>
          </table>
          {otherIncomeBreakdown.length > 5 && (
            <button class="expand-toggle" aria-expanded="false">Show More</button>
          )}
        </div>
      </div>
    </section>
  )}

  <section class="chart-section">
    <h2>Paid Maintainers Analysis</h2>
    <p class="note">
      Recurring stipend payments only. One-time payments (bonuses, contract work) are not included in these figures.
    </p>
    <p class="salary-total-line">
      Combined maintainer stipends account for
      <strong class:list={{ warning: salaryAnalysis.percentageOfTotalIncome > 100 }}>
        {salaryAnalysis.percentageOfTotalIncome}%
      </strong>
      of average monthly income.
    </p>
    <div class="table-container">
      <table class="maintainers-table">
        <thead>
          <tr>
            <th>Recipient</th>
            <th class="number">Total Paid</th>
            <th class="number">Monthly Avg</th>
            <th class="number">% of Income</th>
            <th class="number">Count</th>
            <th class="number">First</th>
            <th class="number">Last</th>
          </tr>
        </thead>
        <tbody>
          {salariedExpenses.filter((s) => s.paymentCount > 1).map((s) => {
            const percentOfIncome = salaryAnalysis.avgMonthlyIncome > 0
              ? Math.round((s.monthlyAverage / salaryAnalysis.avgMonthlyIncome) * 1000) / 10
              : 0;
            return (
              <tr>
                <td>{s.recipient}</td>
                <td class="number">{formatCurrency(s.totalPaid)}</td>
                <td class="number">{formatCurrency(s.monthlyAverage)}</td>
                <td class="number">{percentOfIncome}%</td>
                <td class="number">{s.paymentCount}</td>
                <td class="number">{s.firstPayment}</td>
                <td class="number">{s.lastPayment}</td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  </section>

  <section class="two-column">
    <div class="chart-section">
      <h2>Top Contributors</h2>
      <div class="table-container">
        <table class="expandable-table" data-visible="5">
          <thead>
            <tr>
              <th>Contributor</th>
              <th class="number">Total</th>
              <th class="number">Count</th>
            </tr>
          </thead>
          <tbody>
            {topContributors.map((c, i) => (
              <tr class:list={{ hidden: i >= 5 }}>
                <td>{c.source}</td>
                <td class="number positive">{formatCurrency(c.amount)}</td>
                <td class="number">{c.count}</td>
              </tr>
            ))}
          </tbody>
        </table>
        {topContributors.length > 5 && (
          <button class="expand-toggle" aria-expanded="false">Show More</button>
        )}
      </div>
    </div>

    <div class="chart-section">
      <h2>Top Recipients</h2>
      <div class="table-container">
        <table class="expandable-table" data-visible="5">
          <thead>
            <tr>
              <th>Recipient</th>
              <th class="number">Total</th>
              <th class="number">Count</th>
            </tr>
          </thead>
          <tbody>
            {topExpenses.map((e, i) => (
              <tr class:list={{ hidden: i >= 5 }}>
                <td>{e.recipient}</td>
                <td class="number negative">{formatCurrency(e.amount)}</td>
                <td class="number">{e.count}</td>
              </tr>
            ))}
          </tbody>
        </table>
        {topExpenses.length > 5 && (
          <button class="expand-toggle" aria-expanded="false">Show More</button>
        )}
      </div>
    </div>
  </section>

  <section class="chart-section">
    <h2>Largest One-Time Contributions</h2>
    <p class="note">Single transactions that are not labeled as "Monthly contribution"</p>
    <div class="table-container">
      <table>
        <thead>
          <tr>
            <th>Date</th>
            <th>Source</th>
            <th class="number">Amount</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          {largestOneTime.map((c) => (
            <tr>
              <td class="date">{c.date}</td>
              <td>{c.source}</td>
              <td class="number positive">{formatCurrency(c.amount)}</td>
              <td class="description">{c.description}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

</Layout>

<script type="application/json" id="chart-data" set:html={JSON.stringify({ monthlyData, expensesByCategory, monthlyIncomeSources, otherIncomeBreakdown })} />

<script>
  import Chart from "chart.js/auto";

  const dataElement = document.getElementById("chart-data");
  const { monthlyData, expensesByCategory, monthlyIncomeSources, otherIncomeBreakdown } = JSON.parse(dataElement?.textContent || "{}");

  const colors = {
    green: "#3fb950",
    red: "#f85149",
    blue: "#58a6ff",
    purple: "#a371f7",
    yellow: "#d29922",
    cyan: "#39c5cf",
    orange: "#f0883e",
    pink: "#db61a2",
  };

  /**
   * Creates x-axis tick configuration that ensures bookend labels are always visible.
   * On mobile, shows fewer labels but always includes first and last for context.
   */
  function createResponsiveXTicks(labels: string[]) {
    const totalLabels = labels.length;
    const viewportWidth = window.innerWidth;

    // Determine max labels based on viewport
    let maxLabels: number;
    if (viewportWidth < 480) {
      maxLabels = 4;
    } else if (viewportWidth < 768) {
      maxLabels = 6;
    } else if (viewportWidth < 1024) {
      maxLabels = 10;
    } else {
      maxLabels = 14;
    }

    // Calculate which indices to show (always include first and last)
    const step = Math.max(1, Math.ceil((totalLabels - 1) / (maxLabels - 1)));
    const visibleIndices = new Set<number>();
    visibleIndices.add(0); // First label
    visibleIndices.add(totalLabels - 1); // Last label

    // Add evenly spaced intermediate labels
    for (let i = step; i < totalLabels - 1; i += step) {
      visibleIndices.add(i);
    }

    return {
      color: "#8b949e",
      maxRotation: 45,
      minRotation: 0,
      autoSkip: false,
      callback: function(_value: any, index: number) {
        return visibleIndices.has(index) ? labels[index] : null;
      }
    };
  }

  const chartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        labels: { color: "#c9d1d9" },
      },
    },
    scales: {
      x: {
        ticks: { color: "#8b949e" },
        grid: { color: "#30363d" },
      },
      y: {
        ticks: { color: "#8b949e" },
        grid: { color: "#30363d" },
      },
    },
  };

  const monthlyLabels = monthlyData.map((d: any) => d.month);

  new Chart(document.getElementById("monthlyChart") as HTMLCanvasElement, {
    type: "bar",
    data: {
      labels: monthlyLabels,
      datasets: [
        {
          label: "Income",
          data: monthlyData.map((d: any) => d.income),
          backgroundColor: colors.green,
        },
        {
          label: "Expenses",
          data: monthlyData.map((d: any) => -d.expenses),
          backgroundColor: colors.red,
        },
      ],
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: (context: any) => {
              const value = Math.abs(context.raw);
              const formatted = new Intl.NumberFormat("en-US", { style: "currency", currency: "USD" }).format(value);
              return `${context.dataset.label}: ${formatted}`;
            },
          },
        },
      },
      scales: {
        x: {
          ticks: createResponsiveXTicks(monthlyLabels),
          grid: { color: "#30363d" },
        },
        y: {
          ticks: {
            color: "#8b949e",
            callback: (value: any) => {
              if (Math.abs(value) >= 1000) return (value / 1000).toFixed(0) + "k";
              return value;
            },
          },
          grid: { color: "#30363d" },
        },
      },
    },
  });

  let cumulative = 0;
  const cumulativeData = monthlyData.map((d: any) => {
    cumulative += d.net;
    return cumulative;
  });

  new Chart(document.getElementById("balanceChart") as HTMLCanvasElement, {
    type: "line",
    data: {
      labels: monthlyLabels,
      datasets: [
        {
          data: cumulativeData,
          borderColor: colors.blue,
          backgroundColor: colors.blue + "33",
          fill: true,
          tension: 0.1,
        },
      ],
    },
    options: {
      ...chartOptions,
      plugins: { ...chartOptions.plugins, legend: { display: false } },
      scales: {
        ...chartOptions.scales,
        x: {
          ...chartOptions.scales.x,
          ticks: createResponsiveXTicks(monthlyLabels),
        },
      },
    },
  });

  const incomeSourceLabels = monthlyIncomeSources.map((d: any) => d.month);

  // Calculate Y-axis max from non-Other data, rounded up to nearest 5k
  const incomeYMax = Math.ceil(
    Math.max(...monthlyIncomeSources.flatMap((d: any) => [d.githubSponsors, d.ocRecurring, d.ocOneTime])) / 5000
  ) * 5000;

  // Store actual "Other" values, clamp visual data to Y max
  const otherActualValues = monthlyIncomeSources.map((d: any) => d.other);
  const otherClampedValues = otherActualValues.map((v: number) => Math.min(v, incomeYMax * 0.97));

  new Chart(document.getElementById("incomeSourcesChart") as HTMLCanvasElement, {
    type: "line",
    data: {
      labels: incomeSourceLabels,
      datasets: [
        {
          label: "GitHub Sponsors",
          data: monthlyIncomeSources.map((d: any) => d.githubSponsors),
          borderColor: colors.pink,
          backgroundColor: colors.pink + "33",
          fill: true,
        },
        {
          label: "OC Recurring",
          data: monthlyIncomeSources.map((d: any) => d.ocRecurring),
          borderColor: colors.green,
          backgroundColor: colors.green + "33",
          fill: true,
        },
        {
          label: "OC One-Time",
          data: monthlyIncomeSources.map((d: any) => d.ocOneTime),
          borderColor: colors.purple,
          backgroundColor: colors.purple + "33",
          fill: true,
        },
        {
          label: "Other",
          data: otherClampedValues,
          borderColor: colors.orange,
          backgroundColor: colors.orange + "33",
          fill: true,
          pointStyle: otherActualValues.map((v: number, i: number) =>
            v > otherClampedValues[i] ? "triangle" : "circle"
          ),
          pointRadius: otherActualValues.map((v: number, i: number) =>
            v > otherClampedValues[i] ? 6 : 3
          ),
        },
      ],
    },
    options: {
      ...chartOptions,
      interaction: {
        mode: "nearest",
        intersect: true,
      },
      plugins: {
        ...chartOptions.plugins,
        tooltip: {
          callbacks: {
            label: (context: any) => {
              // Use actual value for "Other", not clamped
              let value = context.raw;
              if (context.dataset.label === "Other") {
                value = otherActualValues[context.dataIndex];
              }
              const formatted = new Intl.NumberFormat("en-US", { style: "currency", currency: "USD" }).format(value);
              return `${context.dataset.label}: ${formatted}`;
            },
            afterLabel: (context: any) => {
              const dataIndex = context.dataIndex;
              const datasetLabel = context.dataset.label;
              const monthData = monthlyIncomeSources[dataIndex];
              if (!monthData) return [];

              const lines: string[] = [];
              let contributors: any[] = [];

              if (datasetLabel === "OC Recurring" && monthData.topRecurring?.length > 0) {
                contributors = monthData.topRecurring;
              } else if (datasetLabel === "OC One-Time" && monthData.topOneTime?.length > 0) {
                contributors = monthData.topOneTime;
              }

              contributors.forEach((c: any) => {
                const amt = new Intl.NumberFormat("en-US", { style: "currency", currency: "USD" }).format(c.amount);
                lines.push(`  ${c.name}: ${amt}`);
              });

              return lines;
            },
          },
        },
      },
      scales: {
        ...chartOptions.scales,
        x: {
          ...chartOptions.scales.x,
          ticks: createResponsiveXTicks(incomeSourceLabels),
        },
        y: {
          ...chartOptions.scales.y,
          max: incomeYMax,
        },
      },
    },
  });

  const topCategories = expensesByCategory.slice(0, 8);
  const categoryColorMap: Record<string, string> = {
    "Paid Maintainers": "#58a6ff",      // Blue - primary expense, professional
    "Community Incentives": "#a371f7",  // Purple - community/creative
    "OC Fees": "#6e7681",               // Gray - overhead/platform fees
    "Miscellaneous": "#f0883e",         // Orange - varied/other
  };
  const fallbackColors = [colors.cyan, colors.pink, colors.yellow, colors.green];

  // Responsive legend for doughnut chart
  const isMobile = window.innerWidth < 600;
  const doughnutLegendFontSize = isMobile ? 13 : 14;
  const doughnutLegendPadding = isMobile ? 16 : 12;

  new Chart(document.getElementById("expenseCategoryChart") as HTMLCanvasElement, {
    type: "doughnut",
    data: {
      labels: topCategories.map((c: any) => c.source),
      datasets: [
        {
          data: topCategories.map((c: any) => c.amount),
          backgroundColor: topCategories.map((c: any, i: number) =>
            categoryColorMap[c.source] || fallbackColors[i % fallbackColors.length]
          ),
        },
      ],
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      layout: {
        padding: { top: 15 },
      },
      plugins: {
        legend: {
          position: "bottom",
          align: "start",
          title: {
            display: true,
            text: "",
            padding: { top: 20 },
          },
          labels: {
            color: "#c9d1d9",
            font: { size: doughnutLegendFontSize },
            padding: doughnutLegendPadding,
            boxWidth: 14,
            boxHeight: 14,
            generateLabels: (chart: any) => {
              const datasets = chart.data.datasets;
              return chart.data.labels.map((label: string, i: number) => ({
                text: "  " + label,
                fillStyle: datasets[0].backgroundColor[i],
                strokeStyle: datasets[0].backgroundColor[i],
                fontColor: "#c9d1d9",
                lineWidth: 0,
                hidden: false,
                index: i,
              }));
            },
          },
          maxWidth: 1,
        },
        tooltip: {
          callbacks: {
            label: (context: any) => {
              const value = context.raw;
              const total = context.dataset.data.reduce((sum: number, val: number) => sum + val, 0);
              const percentage = ((value / total) * 100).toFixed(1);
              const formatted = new Intl.NumberFormat("en-US", { style: "currency", currency: "USD" }).format(value);
              return `${formatted} (${percentage}%)`;
            },
          },
        },
      },
    },
  });

  // Other Income chart
  const otherIncomeCanvas = document.getElementById("otherIncomeChart") as HTMLCanvasElement | null;
  if (otherIncomeCanvas && otherIncomeBreakdown?.length > 0) {
    // Group small items into "Other" for cleaner chart
    const threshold = 0.02; // 2% threshold
    const total = otherIncomeBreakdown.reduce((sum: number, item: any) => sum + item.amount, 0);

    const significantItems: any[] = [];
    let otherAmount = 0;
    let otherCount = 0;

    for (const item of otherIncomeBreakdown) {
      if (item.amount / total >= threshold) {
        significantItems.push(item);
      } else {
        otherAmount += item.amount;
        otherCount += 1;
      }
    }

    if (otherAmount > 0) {
      significantItems.push({ kind: "Other", source: `${otherCount} small items`, amount: otherAmount, count: otherCount });
    }

    const otherIncomeColors = [colors.blue, colors.purple, colors.cyan, colors.orange, colors.pink, colors.yellow, colors.green, "#6e7681"];

    new Chart(otherIncomeCanvas, {
      type: "doughnut",
      data: {
        labels: significantItems.map((item: any) => item.source || item.kind),
        datasets: [
          {
            data: significantItems.map((item: any) => item.amount),
            backgroundColor: significantItems.map((_: any, i: number) => otherIncomeColors[i % otherIncomeColors.length]),
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        layout: {
          padding: { top: 15 },
        },
        plugins: {
          legend: {
            position: "bottom",
            align: "start",
            labels: {
              color: "#c9d1d9",
              font: { size: isMobile ? 13 : 14 },
              padding: isMobile ? 16 : 12,
              boxWidth: 14,
              boxHeight: 14,
            },
          },
          tooltip: {
            callbacks: {
              title: (context: any) => {
                const item = significantItems[context[0].dataIndex];
                return `${item.kind}: ${item.source || "Unknown"}`;
              },
              label: (context: any) => {
                const value = context.raw;
                const percentage = ((value / total) * 100).toFixed(1);
                const formatted = new Intl.NumberFormat("en-US", { style: "currency", currency: "USD" }).format(value);
                return `${formatted} (${percentage}%)`;
              },
            },
          },
        },
      },
    });
  }

  // Expandable table toggles
  document.querySelectorAll(".expand-toggle").forEach((button) => {
    const container = button.closest(".table-container");
    const table = container?.querySelector(".expandable-table");
    const visibleCount = parseInt(table?.getAttribute("data-visible") || "5", 10);
    const allRows = table?.querySelectorAll("tbody tr");

    button.addEventListener("click", () => {
      const isExpanded = button.getAttribute("aria-expanded") === "true";

      allRows?.forEach((row, i) => {
        if (i >= visibleCount) {
          row.classList.toggle("hidden", isExpanded);
        }
      });

      button.setAttribute("aria-expanded", String(!isExpanded));
      button.textContent = isExpanded ? "Show More" : "Show Less";
    });
  });

</script>

<style>
  .hero-section {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
    margin-bottom: 2rem;
  }

  .hero-left {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .hero-section .summary-cards {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
    align-content: start;
  }

  .hero-section .summary-cards .current-balance {
    grid-column: span 2;
  }

  .hero-section .summary-cards .current-balance .value {
    font-size: 2rem;
  }

  .hero-note {
    font-size: 0.8rem;
    color: var(--color-text-muted);
    font-style: italic;
    line-height: 1.5;
    margin: 0;
  }

  .hero-section .expense-chart {
    margin-bottom: 0;
    min-width: 0;
  }

  .hero-section .expense-chart .chart-container.small {
    height: 350px;
  }

  @media (max-width: 800px) {
    .hero-section {
      grid-template-columns: 1fr;
    }

    .two-column {
      grid-template-columns: 1fr;
    }
  }

  @media (max-width: 600px) {
    .chart-container {
      height: 300px;
    }

    .chart-container.small {
      height: 280px;
    }

    .hero-section .expense-chart .chart-container.small {
      height: 320px;
    }

    .hero-section .summary-cards {
      grid-template-columns: 1fr 1fr;
    }

    .hero-section .summary-cards .current-balance {
      grid-column: span 2;
    }

    .hero-section .summary-cards .current-balance .value {
      font-size: 1.5rem;
    }

    .summary-cards {
      grid-template-columns: 1fr 1fr;
    }

    .two-column .chart-section {
      min-width: 0;
    }
  }

  @media (max-width: 400px) {
    .summary-cards {
      grid-template-columns: 1fr;
    }

    .chart-container {
      height: 250px;
    }
  }

  .summary-cards {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 1rem;
    margin-bottom: 2rem;
  }

  .card {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 8px;
    padding: 1rem;
    text-align: center;
  }

  .card.highlight {
    border-color: var(--color-accent);
  }

  .card h3 {
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 0.5rem;
  }

  .card .value {
    font-size: 1.25rem;
    font-weight: 600;
  }

  .positive {
    color: var(--color-green);
  }

  .negative {
    color: var(--color-red);
  }

  .warning {
    color: var(--color-yellow);
  }

  .chart-section {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 8px;
    padding: 1.5rem;
    margin-bottom: 2rem;
    min-width: 0;
    overflow: hidden;
  }

  .chart-container {
    height: 400px;
    position: relative;
  }

  .chart-container.small {
    height: 300px;
  }


  .two-column {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(min(400px, 100%), 1fr));
    gap: 2rem;
    margin-bottom: 2rem;
  }

  .two-column .chart-section {
    margin-bottom: 0;
    min-width: 0;
  }

  .stats-row {
    display: flex;
    gap: 2rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
  }

  .stat {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .stat-label {
    font-size: 0.75rem;
    color: var(--color-text-muted);
    text-transform: uppercase;
  }

  .stat-value {
    font-size: 1.25rem;
    font-weight: 600;
  }

  .stat-count {
    font-size: 0.75rem;
    color: var(--color-text-muted);
  }

  .salary-total-line {
    font-size: 1rem;
    margin-bottom: 1.5rem;
  }

  .salary-total-line strong {
    font-size: 1.25rem;
  }

  .note {
    font-size: 0.875rem;
    color: var(--color-text-muted);
    margin-bottom: 1.5rem;
    font-style: italic;
  }

  .category-note {
    font-size: 0.75rem;
    line-height: 1.5;
  }

  .category-note span {
    display: block;
    margin-bottom: 0.25rem;
  }

  .category-note strong {
    color: var(--color-text);
    font-style: normal;
  }

  .table-container {
    overflow-x: auto;
    min-width: 0;
  }

  .two-column table td:first-child {
    max-width: 150px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.875rem;
  }

  th,
  td {
    padding: 0.75rem;
    text-align: left;
    border-bottom: 1px solid var(--color-border);
  }

  th {
    font-weight: 600;
    color: var(--color-text-muted);
    font-size: 0.75rem;
    text-transform: uppercase;
  }

  .number {
    font-family: monospace;
    white-space: nowrap;
  }



  td.date {
    white-space: nowrap;
    font-family: monospace;
    color: var(--color-text-muted);
  }

  td.description {
    max-width: 300px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    color: var(--color-text-muted);
    font-size: 0.75rem;
  }

  tr.hidden {
    display: none;
  }

  .expand-toggle {
    width: 100%;
    margin-top: 0.5rem;
    padding: 0.5rem;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 4px;
    color: var(--color-accent);
    font-size: 0.75rem;
    cursor: pointer;
    transition: background-color 0.15s;
  }

  .expand-toggle:hover {
    background: var(--color-border);
  }

  .other-income-layout {
    display: grid;
    grid-template-columns: 300px 1fr;
    gap: 2rem;
    align-items: start;
  }

  @media (max-width: 800px) {
    .other-income-layout {
      grid-template-columns: 1fr;
    }

    .other-income-layout .chart-container.small {
      height: 280px;
    }
  }
</style>
